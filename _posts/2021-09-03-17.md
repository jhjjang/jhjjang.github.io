---
layout: post
title: 25 Pandas Functions You Didnâ€™t Know Existed
---

â€œI wish I could do this operation in Pandasâ€¦.â€

Well, chances are, you can!

Pandas is so vast and deep that it enables you to execute virtually any tabular manipulation you can think of. However, this vastness sometimes comesÂ *at a disadvantage*.

Many elegant features that solve rare edge-cases, unique scenarios are lost in the documentation, shadowed by the more frequently used functions.

This article aims to rediscover those features and show you that Pandas is more capable than you ever knew.

# **1.Â `ExcelWriter`**

`ExcelWriter`Â is a generic class for creating excel files (with sheets!) and writing DataFrames to them. Let's say we have these 2:

```python
# Load two datasets
diamonds = sns.load_dataset("diamonds")
tips = sns.load_dataset("tips")

# Write to the same excel file
with pd.ExcelWriter("data/data.xlsx") as writer:

    diamonds.to_excel(writer, sheet_name="diamonds")
    tips.to_excel(writer, sheet_name="tips")
```

It has additional attributes to specify the DateTime format to be used, whether you want to create a new excel file or modify an existing one, what happens when a sheet exists, etc. Check out the details from theÂ [documentation](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.ExcelWriter.html).

# **2.Â `pipe`**

![https://miro.medium.com/max/1400/1*2MGii6YBvod5EQls2oW1Aw.jpeg](https://miro.medium.com/max/1400/1*2MGii6YBvod5EQls2oW1Aw.jpeg)

**Photo byÂ [Leah Kelley](https://www.pexels.com/@leah-kelley-50725?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)Â onÂ [Pexels](https://www.pexels.com/photo/grayscale-photo-of-man-holding-tobacco-pipe-192473/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)**

`pipe`Â is one of the best functions for doing data cleaning in a concise, compact manner in Pandas. It allows you to chain multiple custom functions into a single operation.

For example, letâ€™s say you have functions toÂ `drop_duplicates`,Â `remove_outliers`,Â `encode_categoricals`Â that accept their own arguments. Here is how you apply all three in a single operation:

```python
df_preped = (diamonds.pipe(drop_duplicates).
                      pipe(remove_outliers, ['price', 'carat', 'depth']).
                      pipe(encode_categoricals, ['cut', 'color', 'clarity'])
            )
```

I like how this function resemblesÂ [Sklearn pipelines](https://towardsdatascience.com/how-to-use-sklearn-pipelines-for-ridiculously-neat-code-a61ab66ca90d). There is more you can do with it, so check out theÂ [documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pipe.html)Â or thisÂ [helpful article](https://towardsdatascience.com/a-better-way-for-data-preprocessing-pandas-pipe-a08336a012bc).

# **3.Â `factorize`**

This function is a pandas alternative to Sklearnâ€™sÂ `LabelEncoder`:

```python
# Mind the [0] at the end
diamonds["cut_enc"] = pd.factorize(diamonds["cut"])[0]

>>> diamonds["cut_enc"].sample(5)

52103    2
39813    0
31843    0
10675    0
6634     0
Name: cut_enc, dtype: int64
```

UnlikeÂ `LabelEncoder`,Â `factorize`Â returns a tuple of two values: the encoded column and a list of the unique categories:

```python
codes, unique = pd.factorize(diamonds["cut"], sort=True)

>>> codes[:10]
array([0, 1, 3, 1, 3, 2, 2, 2, 4, 2], dtype=int64)

>>> unique
['Ideal', 'Premium', 'Very Good', 'Good', 'Fair']
```

# **4.Â `explode`Â - ðŸ¤¯ðŸ¤¯ðŸ¤¯**

![https://miro.medium.com/max/1400/1*y3JFnNAtvOnpS-Ev6SIN9A.jpeg](https://miro.medium.com/max/1400/1*y3JFnNAtvOnpS-Ev6SIN9A.jpeg)

**Photo byÂ [Joshua Sukoff](https://unsplash.com/@joshuas?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)Â onÂ [Unsplash](https://unsplash.com/s/photos/explode?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)**

A function with an interesting name isÂ `explode`. Let's see an example first and then explain:

```python
data = pd.Series([1, 6, 7, [46, 56, 49], 45, [15, 10, 12]]).to_frame("dirty")

>>> data
```

![https://miro.medium.com/proxy/1*avVhEJshuwSiUA4-otqIRg.png](https://miro.medium.com/proxy/1*avVhEJshuwSiUA4-otqIRg.png)

TheÂ `dirty`Â column has two rows where values are recorded as actual lists. You may often see this type of data in surveys as some questions accept multiple answers.

```python
>>> data.explode("dirty", ignore_index=True)
```

![https://miro.medium.com/proxy/1*NxVFb5utbefODj3MBBPEzA.png](https://miro.medium.com/proxy/1*NxVFb5utbefODj3MBBPEzA.png)

`explode`Â takes a cell with an array-like value andÂ *explodes*Â it into multiple rows. SetÂ `ignore_index`Â to True to keep the ordering of a numeric index.

# **5.Â `squeeze`**

![https://miro.medium.com/max/1400/1*mBt5v62bsbg0L2yqCBCqxA.jpeg](https://miro.medium.com/max/1400/1*mBt5v62bsbg0L2yqCBCqxA.jpeg)

**Photo byÂ [cottonbro](https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)Â onÂ [Pexels](https://www.pexels.com/photo/close-up-photo-of-sausage-5875701/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)**

Another function with a funky name isÂ `squeeze`Â and is used in very rare but annoying edge cases.

One of these cases is when a single value is returned from a condition used to subset a DataFrame. Consider this example:

```python
subset = diamonds.loc[diamonds.index < 1, ["price"]]

>>> subset
```

![https://miro.medium.com/proxy/1*j-FQi6KpQHvbRTvabnAqVQ.png](https://miro.medium.com/proxy/1*j-FQi6KpQHvbRTvabnAqVQ.png)

Even though there is just one cell, it is returned as a DataFrame. This can be annoying since you now have to useÂ `.loc`Â again with both the column name and index to access the price.

But, if you knowÂ `squeeze`, you don't have to. The function enables you to remove an axis from a single-cell DataFrame or Series. For example:

```python
>>> subset.squeeze()
326
```

Now, only the scalar is returned. It is also possible to specify the axis to remove:

```python
**>>> subset.squeeze("columns")  # or "rows"

0    326
Name: price, dtype: int64**
```

Note thatÂ `squeeze`Â only works for DataFrames or Series with single values.

# **6. between**

![https://miro.medium.com/max/1400/1*PJYFJmzcTPUyEutj804C3Q.jpeg](https://miro.medium.com/max/1400/1*PJYFJmzcTPUyEutj804C3Q.jpeg)

**Photo byÂ [Justin Dream](https://unsplash.com/@jujudreaminx?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)Â onÂ [Pexels](https://unsplash.com/s/photos/between?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)**

A rather nifty function for boolean indexing numeric features within a range:

```python
# Get diamonds that are priced between 3500 and 3700 dollars
diamonds[diamonds["price"]\
      .between(3500, 3700, inclusive="neither")].sample(5)
```

![https://miro.medium.com/proxy/1*PwCzYy4sUmgZ02O50m7nYA.png](https://miro.medium.com/proxy/1*PwCzYy4sUmgZ02O50m7nYA.png)

# **7.Â `T`**

![https://miro.medium.com/max/1400/1*jhghF1WWkobbE2CkTIVdcQ.jpeg](https://miro.medium.com/max/1400/1*jhghF1WWkobbE2CkTIVdcQ.jpeg)

**Photo byÂ [Pixabay](https://www.pexels.com/@pixabay?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)Â onÂ [Pexels](https://www.pexels.com/photo/close-up-of-illuminated-text-against-black-background-258083/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)**

All DataFrames have a simpleÂ `T`Â attribute, which stands forÂ *transpose*. You may not use it often, but I find it quite useful when displaying DataFrames of theÂ `describe`Â method:

```python
>>> boston.describe().T.head(10)
```

![https://miro.medium.com/proxy/1*qtPXjAM-odmgB3vm9C175A.png](https://miro.medium.com/proxy/1*qtPXjAM-odmgB3vm9C175A.png)

The Boston housing dataset has 30 numeric columns. If you callÂ `describe`Â as-is, the DataFrame will stretch horizontally, making it hard to compare the statistics. Taking the transpose will switch the axes so that summary statistics are given in columns.

# **8. Pandas Styler**

Did you know that Pandas allows you to style DataFrames?

They have aÂ `style`Â attribute, which opens doors to customizations and styles only limited by your HTML and CSS knowledge. I won't discuss the full details of what you can do withÂ `style`Â but only show you my favorite functions:

```python
>>> diabetes.describe().T.drop("count", axis=1)\
                 .style.highlight_max(color="darkred")
```

![https://miro.medium.com/proxy/1*0sHktRcBeUJlV32-eQyQ9A.png](https://miro.medium.com/proxy/1*0sHktRcBeUJlV32-eQyQ9A.png)

Above, we are highlighting cells that hold the maximum value of a column. Another cool styler isÂ `background_gradient`Â which can give columns a gradient background color based on their values:

```python
diabetes.describe().T.drop("count", axis=1).style.background_gradient(
    subset=["mean", "50%"], cmap="Reds"
)
```

![https://miro.medium.com/proxy/1*5Q4Qqsie51W8cAoWaVO13A.png](https://miro.medium.com/proxy/1*5Q4Qqsie51W8cAoWaVO13A.png)

This feature comes especially handy when you are usingÂ `describe`Â on a table with many columns and want to compare summary statistics. Check out the documentation of the stylerÂ [here](https://pandas.pydata.org/docs/reference/style.html).

# **9. Pandas options**

Like Matplotlib, pandas has global settings that you can tweak to change the default behaviors:

```python
>>> dir(pd.options)
['compute', 'display', 'io', 'mode', 'plotting']
```

These settings are divided into 5 modules. Letâ€™s see what settings are there underÂ `display`:

```python
>>> dir(pd.options.display)

['chop_threshold',
 'max_columns',
 'max_colwidth',
 'max_info_columns',
 'max_info_rows',
 'max_rows',
 ...
 'precision',
 'show_dimensions',
 'unicode',
 'width']
```

There are many options underÂ `display`Â but I mostly useÂ `max_columns`Â andÂ `precision`:

```python
# Remove the limit to display the number of cols
pd.options.display.max_columns = None

# Only show 5 numbers after the decimal
pd.options.display.precision = 5  # gets rid of scientific notation
```

You can check out theÂ [documentation](https://pandas.pydata.org/pandas-docs/stable/user_guide/options.html)Â to dig deeper into this wonderful feature.

# **10.Â `convert_dtypes`**

We all know that pandas has an annoying tendency to mark some columns asÂ `object`Â data type. Instead of manually specifying their types, you can useÂ `convert_dtypes`Â method which tries to infer the best data type:

```python
sample = pd.read_csv(
    "data/station_day.csv",
    usecols=["StationId", "CO", "O3", "AQI_Bucket"],
)

>>> sample.dtypes

StationId      object
CO            float64
O3            float64
AQI_Bucket     object
dtype: object

>>> sample.convert_dtypes().dtypes

StationId      string
CO            float64
O3            float64
AQI_Bucket     string
dtype: object
```

Unfortunately, it canâ€™t parse dates due to the caveats of different date-time formats.

# **11.Â `select_dtypes`**

A function I use all the time isÂ `select_dtypes`. I think it is obvious what the function does from its name. It hasÂ `include`Â andÂ `exclude`Â parameters that you can use to select columns including or excluding certain data types.

For example, choose only numeric columns withÂ `np.number`:

```python
# Choose only numerical columns
diamonds.select_dtypes(include=np.number).head()
```

![https://miro.medium.com/proxy/1*6qECYE19Nsas9nFLgLvGwA.png](https://miro.medium.com/proxy/1*6qECYE19Nsas9nFLgLvGwA.png)

OrÂ `exclude`Â them:

```python
# Exclude numerical columns
diamonds.select_dtypes(exclude=np.number).head()
```

![https://miro.medium.com/proxy/1*1iDWK21ubKf7DhQ1lNtwAw.png](https://miro.medium.com/proxy/1*1iDWK21ubKf7DhQ1lNtwAw.png)

# **12.Â `mask`**

![https://miro.medium.com/max/1400/1*BHPTpIiSWChBwxgzMIRHnw.jpeg](https://miro.medium.com/max/1400/1*BHPTpIiSWChBwxgzMIRHnw.jpeg)

**Photo byÂ [Pixabay](https://www.pexels.com/@pixabay?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)Â onÂ [Pexels.](https://www.pexels.com/photo/photo-of-guy-fawkes-mask-with-red-flower-on-top-on-hand-38275/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)**

`mask`Â allows you to quickly replace cell values where a custom condition is true.

For example, letâ€™s say we have survey data collected from people aged 50â€“60.

```python
# Create sample data
ages = pd.Series([55, 52, 50, 66, 57, 59, 49, 60]).to_frame("ages")

ages
```

![https://miro.medium.com/proxy/1*5SfT1XqkOkF2RGcLwXmdMw.png](https://miro.medium.com/proxy/1*5SfT1XqkOkF2RGcLwXmdMw.png)

We will treat ages outside the 50â€“60 range (there are two, 49, and 66) as data entry mistakes and replace them with NaNs.

```python
ages.mask(cond=~ages["ages"].between(50, 60), other=np.nan)
```

![https://miro.medium.com/proxy/1*p2FvnfKyAX3x90b_xc7T4w.png](https://miro.medium.com/proxy/1*p2FvnfKyAX3x90b_xc7T4w.png)

So,Â `mask`Â replaces values that don't meetÂ `cond`Â withÂ `other`.

# **13.Â `min`Â andÂ `max`Â along the columns axis**

Even thoughÂ `min`Â andÂ `max`Â functions are well-known, they have another useful property for some edge-cases. Consider this dataset:

```python
index = ["Diamonds", "Titanic", "Iris", "Heart Disease", "Loan Default"]
libraries = ["XGBoost", "CatBoost", "LightGBM", "Sklearn GB"]

df = pd.DataFrame(
    {lib: np.random.uniform(90, 100, 5) for lib in libraries}, index=index
)

>>> df
```

![https://miro.medium.com/proxy/1*sVADHdU0MOtLnzQ6mBCYlA.png](https://miro.medium.com/proxy/1*sVADHdU0MOtLnzQ6mBCYlA.png)

The above fake DataFrame is a point-performance of 4 different gradient boosting libraries on 5 datasets. We want to find the library that performed best at each dataset. Here is how you do it elegantly withÂ `max`:

```python
>>> df.max(axis=1)

Diamonds         99.52684
Titanic          99.63650
Iris             99.10989
Heart Disease    99.31627
Loan Default     97.96728
dtype: float64
```

Just change the axis to 1, and you get a row-wise max/min.

# **14.Â `nlargest`Â andÂ `nsmallest`**

Sometimes you donâ€™t just want the min/max of a column. You want to see the top N or ~(top N) values of a variable. This is whereÂ `nlargest`Â andÂ `nsmallest`Â comes in handy.

Letâ€™s see the top 5 most expensive and cheapest diamonds:

```python
diamonds.nlargest(5, "price")
```

![https://miro.medium.com/proxy/1*95ww3IXtZ3X1k3ufkRAx-Q.png](https://miro.medium.com/proxy/1*95ww3IXtZ3X1k3ufkRAx-Q.png)

![https://miro.medium.com/proxy/1*LFGP_dU1ICU2bY5Nx2vymg.png](https://miro.medium.com/proxy/1*LFGP_dU1ICU2bY5Nx2vymg.png)

# **15.Â `idxmax`Â andÂ `idxmin`**

When you callÂ `max`Â orÂ `min`Â on a column, pandas returns the value that is largest/smallest. However, sometimes you want theÂ *position*Â of the min/max, which is not possible with these functions.

Instead, you should useÂ `idxmax`/`idxmin`:

```python
>>> diamonds.price.idxmax()
27749

>>> diamonds.carat.idxmin()
14
```

You can also specify theÂ `columns`Â axis, in which case the functions return the index number of the column.

# **16.Â `value_counts`Â withÂ `dropna=False`**

A common operation to find the percentage of missing values is to chainÂ `isnull`Â andÂ `sum`Â and divide by the length of the array.

But, you can do the same thing withÂ `value_counts`Â with relevant arguments:

```python
ames_housing = pd.read_csv("data/train.csv")

>>> ames_housing["FireplaceQu"].value_counts(dropna=False, normalize=True)

NaN    0.47260
Gd     0.26027
TA     0.21438
Fa     0.02260
Ex     0.01644
Po     0.01370
Name: FireplaceQu, dtype: float64
```

Fireplace quality of Ames housing dataset consists of 47% nulls.

# **17.Â `clip`**

![https://miro.medium.com/max/1400/1*2wsV_LdCUFHfI85vie1EKA.jpeg](https://miro.medium.com/max/1400/1*2wsV_LdCUFHfI85vie1EKA.jpeg)

**Photo byÂ [Ann H](https://www.pexels.com/@ann-h-45017?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)Â onÂ [Pexels](https://www.pexels.com/photo/a-lot-of-paper-clips-2448452/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)**

Outlier detection and removal are common in data analysis.

`clip`Â function makes it really easy to find outliers outside a range and replace them with the hard limits.

Letâ€™s go back to the ages example:

![https://miro.medium.com/proxy/1*5SfT1XqkOkF2RGcLwXmdMw.png](https://miro.medium.com/proxy/1*5SfT1XqkOkF2RGcLwXmdMw.png)

This time, we will replace the out-of-range ages with the hard limits of 50 and 60:

```python
>>> ages.clip(50, 60)
```

![https://miro.medium.com/proxy/1*xQb0KWCaVyn-3qToFkZNBA.png](https://miro.medium.com/proxy/1*xQb0KWCaVyn-3qToFkZNBA.png)

Fast and efficient!

# **18.Â `at_time`Â andÂ `between_time`**

These two can be useful when working with time series that have high granularity.

`at_time`Â allows you to subset values at a specific date or time. Consider this time series:

```python
index = pd.date_range("2021-08-01", periods=100, freq="H")
data = pd.DataFrame({"col": list(range(100))}, index=index)

>>> data.head()
```

![https://miro.medium.com/proxy/1*DtdGuUCCZ0N6yVMgdKB0Dg.png](https://miro.medium.com/proxy/1*DtdGuUCCZ0N6yVMgdKB0Dg.png)

Letâ€™s select all rows at 3 PM:

```python
>>> data.at_time("15:00")
```

![https://miro.medium.com/proxy/1*E-ZG-Qw-SoUxZuev7QVEcQ.png](https://miro.medium.com/proxy/1*E-ZG-Qw-SoUxZuev7QVEcQ.png)

Cool, huh? Now, letâ€™s useÂ `between_time`Â to select rows within a custom interval:

```python
from datetime import datetime

>>> data.between_time("09:45", "12:00")
```

![https://miro.medium.com/proxy/1*j64veEQOMlCpdmQ_q6M9KA.png](https://miro.medium.com/proxy/1*j64veEQOMlCpdmQ_q6M9KA.png)

Note that both functions require a DateTimeIndex, and they only work with times (as inÂ *oâ€™clock*). If you want to subset within a DateTime interval, useÂ `between`.

# **19.Â `bdate_range`**

`bdate_range`Â is a short-hand function to create TimeSeries indices with business-day frequency:

```python
series = pd.bdate_range("2021-01-01", "2021-01-31")  # A period of one month

>>> len(series)
21
```

Business-day frequencies are common in the financial world. So, this function may come in handy when reindexing existing time-series withÂ `reindex`Â function.

# **20.Â `autocorr`**

One of the critical components in time-series analysis is examining the autocorrelation of a variable.

Autocorrelation is theÂ [plain-old correlation coefficient](https://towardsdev.com/how-to-not-misunderstand-correlation-75ce9b0289e), but it is calculated with the lagging version of a time series.

In more detail, the autocorrelation of a time series atÂ `lag=k`Â is calculated as follows:

1. The time-series is shifted tillÂ `k`Â periods:

```python
time_series = tips[["tip"]]
time_series["lag_1"] = time_series["tip"].shift(1)
time_series["lag_2"] = time_series["tip"].shift(2)
time_series["lag_3"] = time_series["tip"].shift(3)
time_series["lag_4"] = time_series["tip"].shift(4)
# time_series['lag_k'] = time_series['tip'].shift(k)

>>> time_series.head()
```

![https://miro.medium.com/proxy/1*BMEAigusWFvfk_joAhyQxw.png](https://miro.medium.com/proxy/1*BMEAigusWFvfk_joAhyQxw.png)

2. Correlation is calculated between the originalÂ `tip`Â and eachÂ `lag_*`.

Instead of doing all this manually, you can use theÂ `autocorr`Â function of Pandas:

```python
# Autocorrelation of tip at lag_10
>>> time_series["tip"].autocorr(lag=8)
0.07475238789967077
```

You can read more about the importance of autocorrelation in time-series analysis from thisÂ [post](https://towardsdatascience.com/advanced-time-series-analysis-in-python-decomposition-autocorrelation-115aa64f475e).

# **21.Â `hasnans`**

Pandas offers a quick method to check if a given series contains any nulls withÂ `hasnans`Â attribute:

```python
series = pd.Series([2, 4, 6, "sadf", np.nan])

>>> series.hasnans
True
```

According to itsÂ [documentation](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.hasnans.html), it enables various performance increases. Note that the attribute works only onÂ `pd.Series`.

# **22.Â `at`Â andÂ `iat`**

These two accessors are much faster alternatives toÂ `loc`Â andÂ `iloc`Â with a disadvantage. They only allow selecting or replacing a single value at a time:

```python
# [index, label]
>>> diamonds.at[234, "cut"]
'Ideal'

# [index, index]
>>> diamonds.iat[1564, 4]
61.2

# Replace 16541th row of the price column
>>> diamonds.at[16541, "price"] = 10000
```

# **23.Â `argsort`**

You should use this function when you want to extract the indices that would sort an array:

```python
tips.reset_index(inplace=True, drop=True)

sort_idx = tips["total_bill"].argsort(kind="mergesort")

# Now, sort `tips` based on total_bill
tips.iloc[sort_idx].head()
```

![https://miro.medium.com/proxy/1*dN6FynHQZ3m3q3BPzZZgzA.png](https://miro.medium.com/proxy/1*dN6FynHQZ3m3q3BPzZZgzA.png)

# **24.Â `cat`Â accessor**

It is common knowledge that Pandas enables to use built-in Python functions on dates and strings using accessors likeÂ `dt`Â orÂ `str`.

Pandas also has a specialÂ `category`Â data type for categorical variables as can be seen below:

```python
>>> diamonds.dtypes

carat       float64
cut        category
color      category
clarity    category
depth       float64
table       float64
price         int64
x           float64
y           float64
z           float64
cut_enc       int64
dtype: object
```

When a column isÂ `category`, you can use several special functions using theÂ `cat`Â accessor. For example, let's see the unique categories of diamond cuts:

```python
>>> diamonds["cut"].cat.categories
['Ideal', 'Premium', 'Very Good', 'Good', 'Fair']
```

There are also functions likeÂ `remove_categories`Â orÂ `rename_categories`, etc.:

```python
diamonds["new_cuts"] = diamonds["cut"].cat.rename_categories(list("ABCDE"))

>>> diamonds["new_cuts"].cat.categories
Index(['A', 'B', 'C', 'D', 'E'], dtype='object')
```

You can see the full list of functions under theÂ `cat`Â accessorÂ [here](https://pandas.pydata.org/pandas-docs/stable/reference/series.html#categorical-accessor).

# **25.Â `GroupBy.nth`**

This function only works withÂ `GroupBy`Â objects. Specifically, after grouping,Â `nth`Â returns the nth row from each group:

```python
>>> diamonds.groupby("cut").nth(5)
```

![https://miro.medium.com/proxy/1*UBgxTvcL5lPfG1EBHS8zDg.png](https://miro.medium.com/proxy/1*UBgxTvcL5lPfG1EBHS8zDg.png)

# **Summary**

Even though libraries like Dask and datatable are slowly winning over Pandas with their shiny new features for handling massive datasets, Pandas remains the most widely-used data manipulation tool in the Python data science ecosystem.

The library is a role model for other packages to imitate and improve upon, as it integrates into the modern SciPy stack so well.

Thank you for reading!
